from __future__ import annotations

import numpy as np
import scipy.sparse
import scipy.stats
from stardist.models import StarDist2D
from stardist.plot import render_label
import skimage.segmentation
from PIL import Image
import cv2
import seaborn as sns
import scanpy as sc
from .coordinate_utils import get_mpp_coords
# 设置PIL和OpenCV的最大图像像素
Image.MAX_IMAGE_PIXELS = None
import os
os.environ["OPENCV_IO_MAX_IMAGE_PIXELS"] = str(2**40)
from .image_utils import load_image, normalize

def stardist(image_path, labels_npz_path, stardist_model="2D_versatile_he", block_size=4096, min_overlap=128,
             context=128, **kwargs):
    '''
    Segment an image with StarDist. Supports both the fluorescence and
    H&E models. The identified object labels will be converted to a
    sparse matrix and written to drive in ``.npz``.

    Input
    -----
    image_path : ``filepath``
        Path to image to be segmented.
    labels_npz_path : ``filepath``
        Path to write object labels output. Can be easily loaded via
        ``scipy.sparse.load_npz()``.
    stardist_model : ``str``, optional (default: ``"2D_versatile_he"``)
        Use ``"2D_versatile_he"`` for segmenting H&E images or
        ``"2D_versatile_fluo"`` for segmenting single-channel
        images (GEX-derived or IF)
    block_size : ``int``, optional (default: 4096)
        StarDist ``predict_instances_big()`` input. Length of square edge
        of the image to process as a single tile.
    min_overlap : ``int``, optional (default: 128)
        StarDist ``predict_instances_big()`` input. Minimum overlap between
        adjacent tiles, in each dimension.
    context : ``int``, optional (default: 128)
        StarDist ``predict_instances_big()`` input. Amount of image context
        on all sides of a block, which is discarded.
    kwargs
        Any additional arguments to pass to StarDist. Practically most likely
        to be ``prob_thresh`` for controlling the stringency of calling
        objects.
    '''
    # using stardist models requires tensorflow, avoid global import
    from stardist.models import StarDist2D
    # load and percentile normalize image, following stardist demo protocol
    # turn it to np.float16 pre normalisation to keep RAM footprint minimal
    img = load_image(image_path, gray=(stardist_model == "2D_versatile_fluo"), dtype=np.float16)
    img = normalize(img)
    # use pretrained stardist model
    model = StarDist2D.from_pretrained(stardist_model)
    # will need to specify axes shortly, which are model dependent
    if stardist_model == "2D_versatile_he":
        # 3D image, got the axes YXC from the H&E model config.json
        model_axes = "YXC"
    elif stardist_model == "2D_versatile_fluo":
        # 2D image, got the axes YX from logic and trying and it working
        model_axes = "YX"
    # run predict_instances_big() to perform automated tiling of the input
    # this is less parameterised than predict_instances, needed to pass axes too
    # pass any other **kwargs to the thing, passing them on internally
    # in practice this is going to be prob_thresh
    labels, _ = model.predict_instances_big(img, axes=model_axes,
                                            block_size=block_size,
                                            min_overlap=min_overlap,
                                            context=context,
                                            **kwargs
                                            )
    # store resulting labels as sparse matrix NPZ - super efficient space wise
    labels_sparse = scipy.sparse.csr_matrix(labels)
    scipy.sparse.save_npz(labels_npz_path, labels_sparse)
    print("Found " + str(len(np.unique(labels_sparse.data))) + " objects")


def view_stardist_labels(image_path, labels_npz_path, crop, **kwargs):
    '''
    Use StarDist's label rendering to view segmentation results in a crop
    of the input image.

    Obsoleted by ``b2c.view_labels()``.

    Input
    -----
    image_path : ``filepath``
        Path to image that was segmented.
    labels_npz_path : ``filepath``
        Path to sparse labels generated by ``b2c.stardist()``.
    crop : tuple of ``int``
        A PIL-formatted crop specification - a four integer tuple,
        provided as (left, upper, right, lower) coordinates.
    kwargs
        Any additional arguments to pass to StarDist's ``render_labels()``.
        Practically most likely to be ``normalize_img``.
    '''
    # PIL is better at handling crops memory efficiently than cv2
    img = Image.open(image_path)
    img = img.crop(crop)
    # stardist likes images on a 0-1 scale
    img = np.array(img) / 255
    # load labels and subset to area of interest
    # crop is (left, upper, right, lower)
    # https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.crop
    labels_sparse = scipy.sparse.load_npz(labels_npz_path)
    # upper:lower, left:right
    labels_sparse = labels_sparse[crop[1]:crop[3], crop[0]:crop[2]]
    # reset labels within crop to start from 1 and go up by 1
    # which makes the stardist view more colourful in objects
    # calling this on [5,7,7,9] yields [1,2,2,3] which is what we want
    labels_sparse.data = scipy.stats.rankdata(labels_sparse.data, method="dense")
    labels = np.array(labels_sparse.todense())
    return render_label(labels, img=img, **kwargs)


def insert_labels(adata, labels_npz_path, basis="spatial", spatial_key="spatial", mpp=None, labels_key="labels"):
    '''
    Load StarDist segmentation results and store them in the object. Labels
    will be stored as integers, with 0 being unassigned to an object.

    Input
    -----
    adata : ``AnnData``
        2um bin VisiumHD object.
    labels_npz_path : ``filepath``
        Path to sparse labels generated by ``b2c.stardist()``.
    basis : ``str``, optional (default: ``"spatial"``)
        Whether the image represents ``"spatial"`` or ``"array"`` coordinates.
        The former is the source morphology image, the latter is a GEX-based grid
        representation.
    spatial_key : ``str``, optional (default: ``"spatial"``)
        Only used with ``basis="spatial"``. Needs to be present in ``.obsm``.
        Rounded coordinates will be used to represent each bin when retrieving
        labels.
    mpp : ``float`` or ``None``, optional (default: ``None``)
        The mpp value that was used to generate the segmented image. Mandatory
        for GEX (``basis="array"``), if not provided with morphology
        (``basis="spatial"``) will assume full scale image.
    labels_key : ``str``, optional (default: ``"labels"``)
        ``.obs`` key to store the labels under.
    '''
    # load sparse segmentation results
    labels_sparse = scipy.sparse.load_npz(labels_npz_path)
    # may as well stash that path in .uns['bin2cell'] since we have it
    if "bin2cell" not in adata.uns:
        adata.uns["bin2cell"] = {}
    if "labels_npz_paths" not in adata.uns["bin2cell"]:
        adata.uns["bin2cell"]["labels_npz_paths"] = {}
    # store as absolute path if it's relative
    if labels_npz_path[0] != "/":
        npz_prefix = os.getcwd() + "/"
    else:
        npz_prefix = ""
    adata.uns["bin2cell"]["labels_npz_paths"][labels_key] = npz_prefix + labels_npz_path
    # get the appropriate coordinates, be they spatial or array, at appropriate mpp
    coords = get_mpp_coords(adata, basis=basis, spatial_key=spatial_key, mpp=mpp)
    # there is a possibility that some coordinates will fall outside labels_sparse
    # start by pregenerating an obs column of all zeroes so all bins are covered
    adata.obs[labels_key] = 0
    # can now construct a mask defining which coordinates fall within range
    # apply the mask to the coords and the obs to just go for the relevant bins
    mask = ((coords[:, 0] >= 0) &
            (coords[:, 0] < labels_sparse.shape[0]) &
            (coords[:, 1] >= 0) &
            (coords[:, 1] < labels_sparse.shape[1])
            )
    # pull out the cell labels for the coordinates, can just index the sparse matrix with them
    # insert into bin object, need to turn it into a 1d numpy array from a 1d numpy matrix first
    adata.obs.loc[mask, labels_key] = np.asarray(labels_sparse[coords[mask, 0], coords[mask, 1]]).flatten()

print("stardist_utils.py loaded")